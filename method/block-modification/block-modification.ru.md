# Способы модификации блока

В БЭМ-методологии блоки — это универсальные, повторно используемые компоненты страницы. Одни и те же блоки используются в разных проектах, однако это не означает, что блоки не могут изменяться в зависмости от рпоекта:

* [Модификатором](#Модификатором)
* [Миксом](#Миксом)
* [Уровнем переопределения](#Уровнем-переопределения)
* [Контекстом](#Контекстом)

Изменение блока любым из перечисленных выше способов не требует:

* копировать код блока для внесения изменений;
* изменять исходную реализацию блока;
* создавать новый блок на основе существующего для внесения изменений.

## Модификатором

Изменение блока производится при помощи установки/снятия модификатора, код которого описывает изменения. Блоку можно добавлять одновременно [несколько модификаторов](#Добавление-нескольких-модификаторов).

Модификатор может задавать блоку:

* [внешний вид](#Изменение-внешнего-вида-блока)
* [поведение](#Изменение-поведения-блока)
* [состояние](#Булевый-модификатор)
* [структуру](#Изменение-структуры-блока)

### Когда использовать



Создавайте модификатор, если нужная вам реализация может использоваться повторно и не зависит от реализации других компонентов страницы. 

#### Булевый модификатор 

Используется, если важно только наличие или отсутствие модификатора у блока, а его значение несущественно. Например, модификатор, описывающий состояние «отключен»:TODO `disabled`:

```
<div class="button button_disabled">...</div>
```

#### Модификатор вида «ключ-значение»

Используется, если значений у модификатора может быть несколько. Например, для описания размеров блока можно использовать модификатор `size` с допустимыми значениями `s`, `m` и `l`:

```
<div class="button button_size_s">...</div>
<div class="button button_size_m">...</div>
```

### Примеры

Рассмотрим все случаи изменения блока с помощью модификатора на примере блока `popup`.

Блок `popup` по умолчанию:

HTML-реализация:

```html
    <!-- Блок popup -->
    <div class="popup">...</div>
```

Отображение:

![Transparent popup](https://github.com/innabelaya/bem-docs/blob/master/pics/block-modification/popup_default.png?raw=true)

#### Изменение внешнего вида блока 

Модификатор `theme` в значении `sun` задает желтый фон всплывающему окну.

HTML-реализация:

```html
    <!-- Блок popup с модификатором theme в значении sun-->
    <div class="popup popup_theme_sun">...</div>
```

Отображение:

![Yellow background modifier for popup block](https://github.com/innabelaya/bem-docs/blob/master/pics/block-modification/popup_theme_sun.png?raw=true)

#### Изменение поведения блока

Модификатор `direction` отвечает за направление открытия всплывающего окна.

Например, модификатор `direction` в значении `left` открывает всплывающее влево.

HTML-реализация:

```html
    <!-- Блок popup -->
    <div class="popup popup_direction_left">...</div>
```

Отображение:

![Left direction modifier for popup block](https://github.com/innabelaya/bem-docs/blob/master/pics/block-modification/popup_left.png?raw=true)

Модификатор `direction` в значении `bottom` открывает всплывающее окно вниз.

HTML-реализация:

```html
    <!-- Блок popup -->
    <div class="popup popup_direction_bottom">...</div>
```

Отображение:

![Bottom direction modifier for popup block](https://github.com/innabelaya/bem-docs/blob/master/pics/block-modification/popup_bottom.png?raw=true)

#### Изменение структуры блока

Модификатор `has-tail` в значении `true` добавляет блоку `popup` новый элемент — «хвостик». Также модификатор добавляет отступы блоку, освобождая место для хвостика.

HTML-реализация:

```html
    <!-- Блок popup -->
    <div class="popup popup_has-tail">...</div>
```

![Modifier for adding tail element to popup](https://github.com/innabelaya/bem-docs/blob/master/pics/block-modification/popup__tail_1.png?raw=true)

#### Добавление нескольких модификаторов 

Блоку можно добавлять неограниченное количество модификаторов. Например:

* `theme` в значении `sun`;
* `direction` в значении `bottom`. 

HTML-реализация:

```html
    <!-- Блок popup -->
    <div class="popup popup_theme_sun popup_direction_bottom">...</div>
```

Всплывающее окно откроется вниз и будет иметь желтый фон:

![Bottom direction modifier for yellow popup block](https://github.com/innabelaya/bem-docs/blob/master/pics/block-modification/popup_bottom_theme_sun.png?raw=true)


## Миксом

Изменение блока производится при помощи размещения дополнительных БЭМ-сущностей на одном DOM-узле с блоком. [Миксы](../method/key-concepts.ru.md#Микс) позволяют совмещать поведение и стили нескольких сущностей без дублирования кода.

### Когда использовать
 
В большинстве случаев микс используется, если необходимо:

* [задать внешнюю геометрию блока](#Внешняя-геометрия-и-позиционирование)
* TODO[одинаково стилизовать разные HTML-элементы](#Стилизация-групп-блоков)

### Примеры

#### Внешняя геометрия и позиционирование

В CSS по БЭМ стили, отвечающие за внешнюю геометрию и позиционирование, задаются через родительский блок.

HTML-реализация:

```html
<!-- Блок `header` -->
<header class="header">
    <button class="button header__button">...</button>
</header>
```

CSS-реализация кнопки:

```css
.button {
    font-family: Arial, sans-serif;
    text-align: center;
    border: 1px solid black;    /* Рамка */
}
.header__button {
    margin: 30px;               /* Отступ */
    position: relative;
}
```

В данном примере внешняя геометрия и позиционирование блока `button` задана через элемент `header__button`. Блок `button` ничего не знает про отступы и может использоваться повторно в любом месте.

HTML-реализация:

```html
<!-- Блок `footer` -->
<footer class="footer">
    <button class="button">...</button>
</footer>
```

#### Стилизация групп блоков

Иногда необходимо применить одинаковое TODO (заменить на стилизацию)форматирование сразу к нескольким различным HTML-элементам страницы. Обычно для решения подобных задач применяют групповые селекторы, которые позволяют быстро изменить дизайн страницы. Однако групповые селекторы увеличивают связанность кода.

В примере ниже текст внутри блоков `article` и `copyright` имеет один и тот же цвет и шрифт.

HTML-реализация:

```
<article class="article">...</article>

<footer class="footer">
    <div class="copyright">...</div>
</footer>
```

CSS-реализация:

```css
article, .footer div {
    font-family: Arial, sans-serif;
    font-size: 14px;
    color: #000;
}
```

В БЭМ для того, чтобы единообразно отформатировать набор HTML-элементов, используются миксы. 

В примере ниже блок `text` содержит все правила для стилизации блоков `article` и `copyright`.

CSS-реализация:

```css
.text {
    font-family: Arial, sans-serif;
    font-size: 14px;
    color: #000;
}
```

Чтобы изменить стили блоков `article` и `copyright`, достаточно примиксовать им блок `text`.

HTML-реализация:

```html
<article class="article text">...</article>

<footer class="footer">
    <div class="copyright text">...</div>
</footer>
```

## Уровнем переопределения

Изменение блока производится при помощи объединения свойств блока с разных уровней переопределения. Изменения блока описываются на отдельном уровне переопределения и подключаются при сборке. 

> Подробнее о [принципах работы уровней переопределения](../redefinition-level/redefinition-level.ru.md)

### Когда использовать

Создавайте изменения на другом уровне переопределения, если: переформулировать
ссыль на док про уровни
* TODOНужная вам реализация может использоваться повторно в различных сборках проекта.  
  Например, [разные темы оформления блоков](../redefinition-level/redefinition-level.ru.md) можно хранить на отдельном уровне и подключать в сборку нужный внешний вид блоков. 
* Исходная реализация блока может обновится, а изменения для проекта необходимо сохранить.  
  Например, уровни переопределения позволяют [сохранить изменения блоков для проекта при обновлении библиотеки](../redefinition-level/redefinition-level.ru.md).
* Общий код проекта необходимо отделить от специфических реализаций.  
  Например, такое разделение кода уместно, если [проект поддерживает разные платформы](../redefinition-level/redefinition-level.ru.md). Общий код для всех платформ хранится на отдельном уровне, а специфические реализации для каждой из платформ — на других. 
* Требуется [провести эксперимент в рабочем проекте](../redefinition-level/redefinition-level.ru.md).  
  Эксперимент проводится на отдельном уровне переопределения, код рабочего проекта остается неизменным.

### Пример

Универсальные блоки из библиотеки должны выглядеть в разных проектах по-разному. Для этого достаточно подключить библиотеку в проект как отдельный уровень и описать изменения блока на другом уровне переопределения.

Исходная реализация блока `button` в библиотеке:

![Исходная реализация кнопки](https://github.com/innabelaya/bem-docs/blob/master/pics/redefinition-level/button-default.png)

Добавим кнопке тень. Для этого доопределим CSS-правила блока `button` на уровне проекта (`project.blocks`).

Файловая система с новым файлом `button.css` на уровне `project.blocks`:

```files
project/
    library.blocks/
        button/
            button.css    # исходная CSS-реализация кнопки в библиотеке

    project.blocks/
        button/
            button.css    # переопределение на уровне проекта (высота 24px)
```

В результате для блока `button` применятся правила с обоих уровней переопределения:

```css
@import "library.blocks/button/button.css";   /* Исходные CSS-правила с уровня библиотеки */
@import "project.blocks/button/button.css";   /* Особенности с уровня project.blocks */
```

Новый внешний вид кнопки:

![Кнопка с тенью](https://github.com/innabelaya/bem-docs/blob/master/pics/block-modification/button-shadow.png)

> [Больше примеров применения уровней переопределения](../redefinition-level/redefinition-level.ru.md)

## Контекстом

Изменение блока производится при помощи размещения одного блока в составе другого. Правила внешнего блока влияют на правила внутреннего.

### Когда использовать

в осно используется для стилизации эл в завсисимости от мод родительскоо блока

Изменять внешний вид и поведение блока контекстом можно только в том случае, если по какой-то причине невозможно использовать микс. Необходимо всегда стремиться использовать миксы, так как при изменении блоков с помощью контекста теряется независимость блоков. 
Пример: CMS кот позволяет пользоватлею когда оставляют комменты, Заранее не известно, то и как будудт писать и правильно ли расставлять мие=ксы. Тогда на род блок навешиваются правила и каскадом применяются


